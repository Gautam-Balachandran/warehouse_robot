<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Autonomous Warehouse Management Robot: PathPlanner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Autonomous Warehouse Management Robot
   </div>
   <div id="projectbrief">The project controls Turtlebot3 to indetify a package in warehouse and drop it to custom location.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classPathPlanner-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PathPlanner Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classPathPlanner.html" title="PathPlanner class computes the shortest path from start to goal. ">PathPlanner</a> class computes the shortest path from start to goal.  
 <a href="classPathPlanner.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PathPlanner_8hpp_source.html">PathPlanner.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a376f30d795cfe0a40f8923f49336f7da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a376f30d795cfe0a40f8923f49336f7da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a376f30d795cfe0a40f8923f49336f7da">PathPlanner</a> ()</td></tr>
<tr class="memdesc:a376f30d795cfe0a40f8923f49336f7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the class. <br /></td></tr>
<tr class="separator:a376f30d795cfe0a40f8923f49336f7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af535c5d5ee4efd61ce39e09263bdd91d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#af535c5d5ee4efd61ce39e09263bdd91d">euclideanDist</a> (std::pair&lt; double, double &gt; point1, std::pair&lt; double, double &gt; point2)</td></tr>
<tr class="memdesc:af535c5d5ee4efd61ce39e09263bdd91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to coompute the Euclidean distance between two nodes.  <a href="#af535c5d5ee4efd61ce39e09263bdd91d">More...</a><br /></td></tr>
<tr class="separator:af535c5d5ee4efd61ce39e09263bdd91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0856952abd30c8afb7d010bc1f12f42c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a0856952abd30c8afb7d010bc1f12f42c">plannerMain</a> ()</td></tr>
<tr class="memdesc:a0856952abd30c8afb7d010bc1f12f42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function that calls all the other functions.  <a href="#a0856952abd30c8afb7d010bc1f12f42c">More...</a><br /></td></tr>
<tr class="separator:a0856952abd30c8afb7d010bc1f12f42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddf7846499907f012e5a3d24e040c26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a7ddf7846499907f012e5a3d24e040c26">setGoal</a> (std::pair&lt; double, double &gt; g)</td></tr>
<tr class="memdesc:a7ddf7846499907f012e5a3d24e040c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for private member, goal.  <a href="#a7ddf7846499907f012e5a3d24e040c26">More...</a><br /></td></tr>
<tr class="separator:a7ddf7846499907f012e5a3d24e040c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf398ecfee4b6a3a7d7249b2c033caa"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#aaaf398ecfee4b6a3a7d7249b2c033caa">getGoal</a> ()</td></tr>
<tr class="memdesc:aaaf398ecfee4b6a3a7d7249b2c033caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for private member, goal.  <a href="#aaaf398ecfee4b6a3a7d7249b2c033caa">More...</a><br /></td></tr>
<tr class="separator:aaaf398ecfee4b6a3a7d7249b2c033caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae689342fe07926fb9510783e2f07b991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#ae689342fe07926fb9510783e2f07b991">setStart</a> (std::pair&lt; double, double &gt; s)</td></tr>
<tr class="memdesc:ae689342fe07926fb9510783e2f07b991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for private member, start.  <a href="#ae689342fe07926fb9510783e2f07b991">More...</a><br /></td></tr>
<tr class="separator:ae689342fe07926fb9510783e2f07b991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab803e1ce6ac612be78c8679f10d451b5"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#ab803e1ce6ac612be78c8679f10d451b5">getStart</a> ()</td></tr>
<tr class="memdesc:ab803e1ce6ac612be78c8679f10d451b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for private member, start.  <a href="#ab803e1ce6ac612be78c8679f10d451b5">More...</a><br /></td></tr>
<tr class="separator:ab803e1ce6ac612be78c8679f10d451b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1eafe65f68d6f3aeb636ac4c43df20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#add1eafe65f68d6f3aeb636ac4c43df20">setPathFound</a> (bool flag)</td></tr>
<tr class="memdesc:add1eafe65f68d6f3aeb636ac4c43df20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for private member pathFound.  <a href="#add1eafe65f68d6f3aeb636ac4c43df20">More...</a><br /></td></tr>
<tr class="separator:add1eafe65f68d6f3aeb636ac4c43df20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de53119e913bcc4f0d69a68a5036a57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a8de53119e913bcc4f0d69a68a5036a57">getPathFound</a> ()</td></tr>
<tr class="memdesc:a8de53119e913bcc4f0d69a68a5036a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for private member pathFound.  <a href="#a8de53119e913bcc4f0d69a68a5036a57">More...</a><br /></td></tr>
<tr class="separator:a8de53119e913bcc4f0d69a68a5036a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab111391044dcb787797a087ec7e57e4a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#ab111391044dcb787797a087ec7e57e4a">hashIndex</a> (std::pair&lt; double, double &gt; node)</td></tr>
<tr class="memdesc:ab111391044dcb787797a087ec7e57e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert cartesian coordinates to hash index.  <a href="#ab111391044dcb787797a087ec7e57e4a">More...</a><br /></td></tr>
<tr class="separator:ab111391044dcb787797a087ec7e57e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac7ef2a9a599c2db3b4670391b919e4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a1ac7ef2a9a599c2db3b4670391b919e4">hashCoordinates</a> (std::size_t hashInd)</td></tr>
<tr class="memdesc:a1ac7ef2a9a599c2db3b4670391b919e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert hash index to cartesian coordinates.  <a href="#a1ac7ef2a9a599c2db3b4670391b919e4">More...</a><br /></td></tr>
<tr class="separator:a1ac7ef2a9a599c2db3b4670391b919e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9aed95ef982c4c5fbfae33a5ca6668b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#aa9aed95ef982c4c5fbfae33a5ca6668b">boundaryCheck</a> (std::pair&lt; double, double &gt; node)</td></tr>
<tr class="memdesc:aa9aed95ef982c4c5fbfae33a5ca6668b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to conduct boundary check and free space check.  <a href="#aa9aed95ef982c4c5fbfae33a5ca6668b">More...</a><br /></td></tr>
<tr class="separator:aa9aed95ef982c4c5fbfae33a5ca6668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0be211569bcef9d59cb6780fbcef3d8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#ac0be211569bcef9d59cb6780fbcef3d8">shortestPath</a> (std::size_t goalHash)</td></tr>
<tr class="memdesc:ac0be211569bcef9d59cb6780fbcef3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the shortest path once goal is reached.  <a href="#ac0be211569bcef9d59cb6780fbcef3d8">More...</a><br /></td></tr>
<tr class="separator:ac0be211569bcef9d59cb6780fbcef3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd383f2dd9d6b7bc45b8a1977597e953"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#afd383f2dd9d6b7bc45b8a1977597e953">updateCost</a> (std::size_t currentHash, std::size_t parentHash, double cost)</td></tr>
<tr class="memdesc:afd383f2dd9d6b7bc45b8a1977597e953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the cost of node and parent of node.  <a href="#afd383f2dd9d6b7bc45b8a1977597e953">More...</a><br /></td></tr>
<tr class="separator:afd383f2dd9d6b7bc45b8a1977597e953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529920e695c8ae9a384a59138c3ae724"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a529920e695c8ae9a384a59138c3ae724">differential</a> (double leftRpm, double rightRpm, double heading, double l, double r, double dt, std::size_t currentHash, double dTheta)</td></tr>
<tr class="memdesc:a529920e695c8ae9a384a59138c3ae724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the new node using differential constrains.  <a href="#a529920e695c8ae9a384a59138c3ae724">More...</a><br /></td></tr>
<tr class="separator:a529920e695c8ae9a384a59138c3ae724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7058d231726ba515e4b1d2cfa4f88e3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a7058d231726ba515e4b1d2cfa4f88e3c">allActions</a> (std::size_t newIndex)</td></tr>
<tr class="memdesc:a7058d231726ba515e4b1d2cfa4f88e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate new nodes in all directions from current node.  <a href="#a7058d231726ba515e4b1d2cfa4f88e3c">More...</a><br /></td></tr>
<tr class="separator:a7058d231726ba515e4b1d2cfa4f88e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e91065460a5ed65eab0df8c1362e74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a77e91065460a5ed65eab0df8c1362e74">goalCheck</a> (std::pair&lt; double, double &gt;)</td></tr>
<tr class="memdesc:a77e91065460a5ed65eab0df8c1362e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if the goal has been reached.  <a href="#a77e91065460a5ed65eab0df8c1362e74">More...</a><br /></td></tr>
<tr class="separator:a77e91065460a5ed65eab0df8c1362e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485d7197e9c2bcfe4a99cafff8baeff7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a485d7197e9c2bcfe4a99cafff8baeff7">showMap</a> ()</td></tr>
<tr class="memdesc:a485d7197e9c2bcfe4a99cafff8baeff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to display the map.  <a href="#a485d7197e9c2bcfe4a99cafff8baeff7">More...</a><br /></td></tr>
<tr class="separator:a485d7197e9c2bcfe4a99cafff8baeff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8a53e6344c45f2de3f0172790f97bfb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a53e6344c45f2de3f0172790f97bfb5"></a>
std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a8a53e6344c45f2de3f0172790f97bfb5">map</a></td></tr>
<tr class="memdesc:a8a53e6344c45f2de3f0172790f97bfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D Vector, holding the occupancy grid of the environment <br /></td></tr>
<tr class="separator:a8a53e6344c45f2de3f0172790f97bfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3879a2e588346eac8c102492b5f7e83f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3879a2e588346eac8c102492b5f7e83f"></a>
std::pair&lt; std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a3879a2e588346eac8c102492b5f7e83f">mapSize</a></td></tr>
<tr class="memdesc:a3879a2e588346eac8c102492b5f7e83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">pair holding the rows and columns size of the map environment <br /></td></tr>
<tr class="separator:a3879a2e588346eac8c102492b5f7e83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81e5aae0bbe71bb0483943e3051f90b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af81e5aae0bbe71bb0483943e3051f90b"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#af81e5aae0bbe71bb0483943e3051f90b">costGo</a></td></tr>
<tr class="memdesc:af81e5aae0bbe71bb0483943e3051f90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector holding the cost to go heuristic for Astar algorithm <br /></td></tr>
<tr class="separator:af81e5aae0bbe71bb0483943e3051f90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2506ae7a5fff04ad938d6a1da8e4b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb2506ae7a5fff04ad938d6a1da8e4b2"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#aeb2506ae7a5fff04ad938d6a1da8e4b2">costCome</a></td></tr>
<tr class="memdesc:aeb2506ae7a5fff04ad938d6a1da8e4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector holding the cost to come heuristic for Astar algorithm <br /></td></tr>
<tr class="separator:aeb2506ae7a5fff04ad938d6a1da8e4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3603445e01a2bf866d459522aba5e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e3603445e01a2bf866d459522aba5e5"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a4e3603445e01a2bf866d459522aba5e5">totalCost</a></td></tr>
<tr class="memdesc:a4e3603445e01a2bf866d459522aba5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector holding the total, cost i.e. cost to come + cost to go from A-star algorithm <br /></td></tr>
<tr class="separator:a4e3603445e01a2bf866d459522aba5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b87bfdf63d46b850df6e1c51521646e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b87bfdf63d46b850df6e1c51521646e"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a0b87bfdf63d46b850df6e1c51521646e">visitStatus</a></td></tr>
<tr class="memdesc:a0b87bfdf63d46b850df6e1c51521646e"><td class="mdescLeft">&#160;</td><td class="mdescRight">boolean vector, holding visit status, 1 if node is previously visited, 0 otherwise <br /></td></tr>
<tr class="separator:a0b87bfdf63d46b850df6e1c51521646e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cc8bafd250349a2068dffa47f7f009"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11cc8bafd250349a2068dffa47f7f009"></a>
std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a11cc8bafd250349a2068dffa47f7f009">parentNode</a></td></tr>
<tr class="memdesc:a11cc8bafd250349a2068dffa47f7f009"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector holding the information of parent node for each child node <br /></td></tr>
<tr class="separator:a11cc8bafd250349a2068dffa47f7f009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa56f17d8fe34d39be8fec0b1407be7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aa56f17d8fe34d39be8fec0b1407be7"></a>
std::vector&lt; std::pair&lt; std::size_t, std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a7aa56f17d8fe34d39be8fec0b1407be7">parentIndexList</a></td></tr>
<tr class="memdesc:a7aa56f17d8fe34d39be8fec0b1407be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector holding the information of each parent child index pairs <br /></td></tr>
<tr class="separator:a7aa56f17d8fe34d39be8fec0b1407be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addabde60666317748139616c18bcfafe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addabde60666317748139616c18bcfafe"></a>
std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#addabde60666317748139616c18bcfafe">actionSequence</a></td></tr>
<tr class="memdesc:addabde60666317748139616c18bcfafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector holding the action of the node that was used to get from the parent node to the child node and has the least cost <br /></td></tr>
<tr class="separator:addabde60666317748139616c18bcfafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab251a1e7b2288fe371314ffdccef6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afab251a1e7b2288fe371314ffdccef6c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#afab251a1e7b2288fe371314ffdccef6c">actionNumber</a></td></tr>
<tr class="memdesc:afab251a1e7b2288fe371314ffdccef6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">integer value that indicates the action being taken <br /></td></tr>
<tr class="separator:afab251a1e7b2288fe371314ffdccef6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aea5a166c62ab1227af43058b40a08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21aea5a166c62ab1227af43058b40a08"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a21aea5a166c62ab1227af43058b40a08">thetaSequence</a></td></tr>
<tr class="memdesc:a21aea5a166c62ab1227af43058b40a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector holding the theta value of the node that was used to get from the parent node to the child node <br /></td></tr>
<tr class="separator:a21aea5a166c62ab1227af43058b40a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba6f4259695316e720e739756bc8e3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ba6f4259695316e720e739756bc8e3c"></a>
std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a8ba6f4259695316e720e739756bc8e3c">stack</a></td></tr>
<tr class="memdesc:a8ba6f4259695316e720e739756bc8e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector holding the list of nodes to be expanded, i.e. the queue <br /></td></tr>
<tr class="separator:a8ba6f4259695316e720e739756bc8e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718c814fcb3d400672e560c499993829"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a718c814fcb3d400672e560c499993829"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a718c814fcb3d400672e560c499993829">goalThreshold</a></td></tr>
<tr class="memdesc:a718c814fcb3d400672e560c499993829"><td class="mdescLeft">&#160;</td><td class="mdescRight">float value, holding the value to create the goal region around goal node <br /></td></tr>
<tr class="separator:a718c814fcb3d400672e560c499993829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19efd1bc9355469eca4c11d6d2fae9e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19efd1bc9355469eca4c11d6d2fae9e5"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a19efd1bc9355469eca4c11d6d2fae9e5">startIndex</a></td></tr>
<tr class="memdesc:a19efd1bc9355469eca4c11d6d2fae9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">variable holding hash index of start node <br /></td></tr>
<tr class="separator:a19efd1bc9355469eca4c11d6d2fae9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8208e1e8bad3fce2252ae4c4d16f6c53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8208e1e8bad3fce2252ae4c4d16f6c53"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a8208e1e8bad3fce2252ae4c4d16f6c53">goalIndex</a></td></tr>
<tr class="memdesc:a8208e1e8bad3fce2252ae4c4d16f6c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">variable holding hash index of goal node <br /></td></tr>
<tr class="separator:a8208e1e8bad3fce2252ae4c4d16f6c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e0d0b12dd6f28021b583ed688fdabf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20e0d0b12dd6f28021b583ed688fdabf"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a20e0d0b12dd6f28021b583ed688fdabf">currentIndex</a></td></tr>
<tr class="memdesc:a20e0d0b12dd6f28021b583ed688fdabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">variable holding hash index of goal node <br /></td></tr>
<tr class="separator:a20e0d0b12dd6f28021b583ed688fdabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d2728bf7bf5033024e3a35ddd9e7d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65d2728bf7bf5033024e3a35ddd9e7d4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#a65d2728bf7bf5033024e3a35ddd9e7d4">goalFlag</a> = 0</td></tr>
<tr class="memdesc:a65d2728bf7bf5033024e3a35ddd9e7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">variable that is set if goal is reached <br /></td></tr>
<tr class="separator:a65d2728bf7bf5033024e3a35ddd9e7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c946eeef27293e5ba8cb91f0a86553"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2c946eeef27293e5ba8cb91f0a86553"></a>
std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPathPlanner.html#ad2c946eeef27293e5ba8cb91f0a86553">localGoal</a></td></tr>
<tr class="memdesc:ad2c946eeef27293e5ba8cb91f0a86553"><td class="mdescLeft">&#160;</td><td class="mdescRight">pair holding cartesian coordinates of the node in the goal threshold at which path search terminated <br /></td></tr>
<tr class="separator:ad2c946eeef27293e5ba8cb91f0a86553"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classPathPlanner.html" title="PathPlanner class computes the shortest path from start to goal. ">PathPlanner</a> class computes the shortest path from start to goal. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7058d231726ba515e4b1d2cfa4f88e3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PathPlanner::allActions </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>newIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate new nodes in all directions from current node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>index of the current node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="aa9aed95ef982c4c5fbfae33a5ca6668b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PathPlanner::boundaryCheck </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; double, double &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to conduct boundary check and free space check. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Node</td><td>coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool, true if in map and free space, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a529920e695c8ae9a384a59138c3ae724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; PathPlanner::differential </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>leftRpm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rightRpm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>heading</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>currentHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dTheta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate the new node using differential constrains. </p>
<p>left wheel velocity in rpm  right wheel velocity in rpm  heading angle  Length of wheel base of robot  wheel radius of robot  time interval  current node hash index  change in heading angle </p><dl class="section return"><dt>Returns</dt><dd>pair containing x and y of new cooordinates </dd></dl>

</div>
</div>
<a class="anchor" id="af535c5d5ee4efd61ce39e09263bdd91d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PathPlanner::euclideanDist </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; double, double &gt;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; double, double &gt;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to coompute the Euclidean distance between two nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Two</td><td>node coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Euclidean distance </dd></dl>

</div>
</div>
<a class="anchor" id="aaaf398ecfee4b6a3a7d7249b2c033caa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; PathPlanner::getGoal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for private member, goal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair holding x and y coordinates of goal point </dd></dl>

</div>
</div>
<a class="anchor" id="a8de53119e913bcc4f0d69a68a5036a57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PathPlanner::getPathFound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for private member pathFound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean value, true if path found, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ab803e1ce6ac612be78c8679f10d451b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; PathPlanner::getStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for private member, start. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair holding x and y coordinates of start point </dd></dl>

</div>
</div>
<a class="anchor" id="a77e91065460a5ed65eab0df8c1362e74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PathPlanner::goalCheck </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; double, double &gt;&#160;</td>
          <td class="paramname"><em>currentNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check if the goal has been reached. </p>
<p>current node to be checked </p><dl class="section return"><dt>Returns</dt><dd>True if goal reached, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a1ac7ef2a9a599c2db3b4670391b919e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; PathPlanner::hashCoordinates </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>hashInd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to convert hash index to cartesian coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>index to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair holding x and y coordinates of node </dd></dl>

</div>
</div>
<a class="anchor" id="ab111391044dcb787797a087ec7e57e4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t PathPlanner::hashIndex </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; double, double &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to convert cartesian coordinates to hash index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair</td><td>holding x and y coordinates of node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash index </dd></dl>

</div>
</div>
<a class="anchor" id="a0856952abd30c8afb7d010bc1f12f42c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, double &gt; &gt; PathPlanner::plannerMain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function that calls all the other functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shortest path from start to goal </dd></dl>

</div>
</div>
<a class="anchor" id="a7ddf7846499907f012e5a3d24e040c26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PathPlanner::setGoal </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; double, double &gt;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setter for private member, goal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair</td><td>holding x and y coordinates of goal point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="add1eafe65f68d6f3aeb636ac4c43df20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PathPlanner::setPathFound </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setter for private member pathFound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boolean</td><td>value, true if path found, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="ae689342fe07926fb9510783e2f07b991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PathPlanner::setStart </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; double, double &gt;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setter for private member, start. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair</td><td>holding x and y coordinates of start point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="ac0be211569bcef9d59cb6780fbcef3d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, double &gt; &gt; PathPlanner::shortestPath </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>goalHash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to find the shortest path once goal is reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>index of node in goal threshold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of pairs containing x and y coordinates/waypoints </dd></dl>

</div>
</div>
<a class="anchor" id="a485d7197e9c2bcfe4a99cafff8baeff7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; int &gt; &gt; PathPlanner::showMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to display the map. </p>
<p>none </p><dl class="section return"><dt>Returns</dt><dd>2D vector holding the map as an occupancy grid </dd></dl>

</div>
</div>
<a class="anchor" id="afd383f2dd9d6b7bc45b8a1977597e953"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PathPlanner::updateCost </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>currentHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>parentHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the cost of node and parent of node. </p>
<p>hash index of the current node  hash index of the parent node  cost of the node </p><dl class="section return"><dt>Returns</dt><dd>bool, true if cost was updated, false otherwise </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/warehouse_robot/<a class="el" href="PathPlanner_8hpp_source.html">PathPlanner.hpp</a></li>
<li>src/<a class="el" href="PathPlanner_8cpp.html">PathPlanner.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
